/*  HASPVDD Driver 
 *
 *  (c) leecher@dose.0wnz.at 2022
 *
 *  This module implements various logging functions for the VDD
 *
 */
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "log.h"

// How to process error messages generated by the module?
enum {
	ERRORMODE_MSGBOX = 0,	// Show MessageBox on fatal error
	ERRORMODE_DBGWRITE = 1,	// Write severe errors just to debug Console
	ERRORMODE_NONE = 2		// Shut up on errors
} ErrorMode;

static DWORD m_ErrorReportingMode = ERRORMODE_MSGBOX;
const char* m_pszWhat[] = { LOGTYPE_STR };
static char* m_hLogFile = INVALID_HANDLE_VALUE;

/* Initializes the logging functions by reading the configuration from the
 * specified Registry path and opens the logfile, if logging buffers to 
 * a file has beed configured.
 * For valid Registry keys and their values, refer to the project 
 * documentation.
 *
 * Parameters:
 *  hKey  - Handle to the registry path containing the settings for the logger
 */
void LogInit(HKEY hKey)
{
	char szPath[MAX_PATH];
	DWORD cbData = sizeof(szPath);

	if (RegQueryValueEx(hKey, "LogFile", NULL, NULL, szPath, &cbData) == ERROR_SUCCESS)
	{
		LogExit();
		m_hLogFile = CreateFile(szPath, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (m_hLogFile == INVALID_HANDLE_VALUE)
			LogLastError("Cannot open HASP logfile: ");
		else
			SetFilePointer(m_hLogFile, 0, 0, FILE_END);
	}

	cbData = sizeof(m_ErrorReportingMode);
	RegQueryValueEx(hKey, "ErrorReportingMode", NULL, NULL, (LPBYTE)&m_ErrorReportingMode, &cbData);

}

/* Shuts down the logging module, closes open logfile handles */
void LogExit(void)
{
	if (m_hLogFile != INVALID_HANDLE_VALUE)
	{
		if (CloseHandle(m_hLogFile))
			m_hLogFile = INVALID_HANDLE_VALUE;
	}
}

/* Shows an error message with the facility specified by one of the ErrorMode 
 * constants.
 *
 * Parameters:
 *  Message  - The message to log
 */
void LogError(char* Message)
{
	switch (m_ErrorReportingMode)
	{
	case ERRORMODE_MSGBOX:
		MessageBox(NULL, Message, "HARDLOCK Error", MB_OK | MB_ICONERROR);
		break;
	case ERRORMODE_DBGWRITE:
		OutputDebugString(Message);
		break;
	}
}

/* Shows an error message with the facility specified by one of the ErrorMode 
 * constants and appends a string representation of the last Windows error 
 * that occured.
 *
 * Parameters:
 *  Message  - The message to log
 */
void LogLastError(char *Message)
{
	char szMsg[512];
	int len;

	len = lstrlen(Message);
	lstrcpy(szMsg, Message);
	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)szMsg + len , sizeof(szMsg) - len, NULL);
	LogError(szMsg);
}

/* Prints out the header so that the dumped data can be interpreted easily
 * by the used reading debug output
 */
void DbgPrintHeader(void)
{
	OutputDebugString(LOG_HEADER);
}

/* Logs a HASP buffer message to the logfile previously opened in LogInit.
 * The log buffer also contains direction and timestamp so that the flow
 * can later by read and dumped by the dumplog utility.
 *
 * Paramters:
 *  Direction  - Direction of the data flow:
 *               0 - Outbound (TO the dongle)
 *               1 - Inbound (read FROM the dongle)
 *               2 - Additional data buffer that gets attached to msg to
 *                   downlevel driver
 *  Data       - The data buffer to log 
 *  Length     - Length of the data buffer to log
 */
void LogMsg(BYTE Direction, PBYTE Data, SIZE_T Length)
{
	LOG_HDR hdr;
	DWORD dwWritten;

	if (m_hLogFile == INVALID_HANDLE_VALUE) return;
	GetSystemTime(&hdr.st);
	hdr.Direction = Direction;
	hdr.Length = (USHORT)Length;
	WriteFile(m_hLogFile, &hdr, sizeof(hdr), &dwWritten, NULL);
	WriteFile(m_hLogFile, Data, Length, &dwWritten, NULL);
}

/* Logs a HASP buffer message to the Debug console and - if configured -
 * also to a logfile that can later by read and dumped by the dumplog utility.
 *
 * Paramters:
 *  Direction  - Direction of the data flow:
 *               0 - Outbound (TO the dongle)
 *               1 - Inbound (read FROM the dongle)
 *               2 - Additional data buffer that gets attached to msg to
 *                   downlevel driver
 *  Data       - The data buffer to log 
 *  Length     - Length of the data buffer to log
 */
void DbgDumpMsg(BYTE Direction, PBYTE Data, SIZE_T Length)
{
	char Msg[2048], * p;
	int i;
	SIZE_T MaxLength = sizeof(Msg);

	i = wsprintf(Msg, "HASP %s [%02X] ", m_pszWhat[Direction], Length);
	MaxLength -= i;
	p = Msg + i;
	MaxLength = Length * 3 > MaxLength ? MaxLength / 3 : Length;
	for (i = 0; i < (int)MaxLength; i++) p += wsprintf(p, "%02X ", Data[i]);
	p += wsprintf(p, "\n");
	OutputDebugString(Msg);
	LogMsg(Direction, Data, Length);
}
